# 아이템 28 - 배열보다는 리스트를 사용하라

## 배열과 제네릭 타입의 차이

* 배열
    * <strong>공변(covariant)</strong>이다 (Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다)
    * 런타임에도 자신이 담기로 한 원소 타입을 인지하고 확인한다.
* 제네릭
    * <strong>불공변</strong>(invariant)이다
    * 타입 정보가 런타임에는 <strong>소거(erasure)</strong>된다. 원소타입을 컴파일 타임에만 검사하며 런타임에는 알 수 없다.

이러한 차이로 배열과 제네릭은 잘 어우러지지 못한다. 제네릭 배열은 만들 수 없는데 타입 안전하지 않기 때문이다.

## 실체화 불가 타입 (non-reifiable type)
실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이다. `E`, `List<E>`, `List<String>` 같은 타입이 실체화 불가 타입에 해당된다.

제네릭 타입과 가변인수 메서드(varargs method)를 함께 쓰면 해석하기 어려운 경고 메시지를 받게 된다. 가변인수 메서드를 호출할 때 마다 가변인수 매개변수를 담을 배열이 하나 만들어지는데, 이때 그 배열의 원소가 실체화 불가 타입이라면 경고가 발생하는 것이다. 이 문제는 `@SafeVarargs` 애너테이션으로 대처할 수 있다

## 배열보다는 리스트

배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우 대부분은 `E[]` 대신 `List<E>`를 사용하면 해결된다. 코드가 조금 복잡해지고 성능이 살짝 나빠질 수도 있지만, 그 대신 타입 안정성과 상호 운용성은 좋아진다.

### 정리
> 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보자.