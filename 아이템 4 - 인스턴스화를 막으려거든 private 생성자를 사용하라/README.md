# 아이템 4 - 인스턴스화를 막으려거든 private 생성자를 사용하라

단순히 정적 메서드와 정적 필드를 담은 클래스를 만들어야 할 때가 있다. 그 예시는 다음과 같다.
* java.lang.Math, java.util.Arrays: 같이 기본 타입 값이나 배열 관련 메서드를 모아놓은 클래스
* java.util.Collections: 특정 인터페이스를 구현하는 객체를 생성해 주는 정적 메서드를 담은 클래스
* final 클래스와 관련한 메서드 (final 클래스를 상속해서 하위 클래스에 메서드를 넣을 수 없기 때문).

정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한것이 아니다. 하지만 생성자를 명시하지 않으면 자바 컴파일러가 자동으로 기본 생성자를 만들어준다. 이로 인해 매개변수를 받지않는 public 생성자가 자동으로 만들어지며, 사용자는 이 생성자에 대해 자동으로 만들어준 것인지, 공개된 API인지 알 수 없다.

이러한 경우 클래스의 인스턴스화를 막기위한 방법은 private 생성자를 사용하는것이다

## private 생성자를 통한 인스턴스화 방지
자동으로 public 생성자를 만들지 못하게 아래와 같이 **private 생성자를 만들어준다.**

```java
public class UtilityClass {

    // 기본 생성자가 만들어 지는 것을 막기위한 private 생성자 (인스턴스화 방지용).
    private UtilityClass() {
        throw new AssertionError();
    }
}
```

명시적 생성자가 private 이니 클래스 바깥에서 이에 접근할 수 없다. 꼭 `AssertionError`를 던질필요는 없다. 중요한것은 클래스 안에서 실수로라도 생성자를 호출하지 않도록 해줄 수 있다는것이다. 또한 직관적으로 인스턴스화를 하지 않기위해 설계하였다는 것을 보여주기 위해 주석도 추가해주는것이 좋다.

이 방법의 단점은 상속을 불가능하게 한다. 모든 생성자는 상위 클래스의 생성자를 호출하게 되는데, 이를 private으로 선언했기 때문이다. 

***
## 추상 클래스를 만들어 인스턴스화를 막는다?
추상 클래스로 만드는 것 또한 인스턴스화를 막을 수 없다. 추상 클래스를 상속하는 하위 클래스를 만들어 이를 인스턴스화하면 그만이다. 또한 사용자는 추상 클래스를 보고 설계상 인스턴스화를 하지 말아야 할 객체로 보는것이 아닌 상속하여 사용하라는 뜻으로 볼 수 있으니 더 문제다.

***
### 정리
> 정적 메서드와 필드를 가진 유틸 클래스에 대해서 인스턴스화를 하지 못하도록 만들고 싶을 때가 있다. 이럴 경우, private 생성자를 사용해 클래스의 인스턴스화를 막을 수 있다. 또한 생성자 내에서 실수라도 발생할 수 있는 호출에 대한 예외처리를 해주는것이 설계한 대로 동작하도록 만들 수 있을 것이다.